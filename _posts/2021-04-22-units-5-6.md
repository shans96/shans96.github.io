---
title: 'Launching into Computer Science- Units 5 & 6'
date: 2021-04-22
permalink: /posts/2021/04/units-5-6/
tags:
  - ePortfolio
  - Launching into Computer Science
---

## Units 5 & 6
I originally began working on the units' content separately, but as I continued, I realized my approach to the content created a lot of overlap between the units' activities; for this reason, I decided to merge their content.

The activity given in this unit instructed me to investigate the features that my OS offers, while an additional task was to contrast two different pieces of software. I always use Windows in a personal capacity (due to my hobbies), although in my career, I've become a frequent user of Linux due to the field I work in (IoT). Rather than create a generic list of features, I found it interesting to list my favorite OS features/applications, and contrast them with the opposite OS: 

- File synchronization across devices (i.e. OneDrive). This is a key feature for me due to the fact that I have a laptop and a desktop computer. Since OneDrive is built into Windows Explorer itself, it provides a seamless experience for sharing work across devices. It's not impossible to implement something similar in Linux (through a utility such as nfs), but there would be associated costs in terms of time (some light bash scripting would likely be needed), and money (a publicly accessible Linux server would be needed to act as an exchange between devices). The convenience which Windows offers is hard to beat, however, doing something similar in Linux would allow room for improvement- for example, one issue I have with OneDrive is that synchronization isn't triggered immediately on saving a file in Word- Word has to be closed first. If this were done in Linux, depending on the method used, it would be possible to add functionality which makes it possible to sync a file at any stage, or even sync autosaved/swap files for consistency.

- Workflow scripting. Both Windows and Linux support this through their respective terminals- cmd and bash. In the case of Windows, however, there is an additional shell known as PowerShell. The intent of PowerShell is to act as a more advanced version of cmd and is intended to replace it (Microsoft, 2019). Although both have support for workflow scripting, Linux is much simpler to work with and easier to understand because it is built around the concept of outputting text. PowerShell, on the other hand, is not built around the concept of outputting text. It is built around the concept of outputting objects, similar to objects in Object Oriented Programming, which all have their own properties and methods. The advantage of this approach is that there is less piping needed because there are multiple utility programs that can manipulate output, however, a major disadvantage is that it now becomes necessary to read documentation more frequently in order to understand how to use programs efficiently. In my experience, working with bash is easy because once you know how to manipulate text output via `grep` or `awk`, you can create very complex tasks. This means it's possible to read the man pages only a few times (for text manipulation programs) and be able to build long-term skill which could be used to solve nearly any problem. PowerShell doesn't have this simplicity and thus has a constant learning curve- it would be necessary to continuously research object properties, valid parameters, and so on, in order to complete varying tasks. No text manipulation means that each new problem requires research. However, it does make for more readable scripts.  

   - As a real-world example to illustrate the difference between the shells, if a user wanted to work out the average memory consumed by specific processes, it would be possible to do this in bash by getting process data via `top`, then piping the text output to `awk` to get the fields, then using mathematical bash operators to get the average. In PowerShell, however, this would be done by calling `Get-Process`, and then piping it to `Measure-Object` (a program which supports calculations such as average and standard deviation) with an argument which references the `VirtualMemorySize` property (because `Get-Process` outputs `Process` objects), and then adding the `Average` flag. The Linux command would look something like this: `top -bn1 | awk '{print $5}' | tail -n +8 | awk '{ total += $1; count++ } END { print total/count }'`, while the entire PowerShell command would be `Get-Process | Measure-Object -Property WorkingSet64 -Average`. Some research was necessary to get the Linux command right, so an argument could be made that research is still required, however, it's important to note that due to the text-based nature of bash, even though I had to research generic terms such as "get first n lines of output", the solution can be applied to any other problem without any extra research whereas with PowerShell, at the very least, I would have to research the object properties produced by a utility and figure out which to use.

An additional task was to investigate the process of creating a folder and a file. Interestingly, on Windows, folders are created in read-only mode by default, but this does not apply to files. The user who created the file and folder have full control over each- that includes reading it, writing to it, and executing it. On an interesting note, both the file and folder were empty, and Windows reported their size as 0 bytes each. Logically speaking, the name of the file and the folder must occupy some space, and thus cannot be 0 bytes. A StackOverflow (2021) question provides insight into this phenomenon; modern filesystems consider metadata (i.e. data which describes the data under inspection) to be separate from the actual content of the data. In other words, filenames and permissions are descriptors, and aren't related to what's inside the file. Another interesting question brought about by this exercise is how different operating systems are designed: Linux treats everything as a file (TLDP, N.D.); in other words, a directory is "just a file containing the names of other files", as opposed to what one may intuitively think, which is that a folder is an object which holds the actual files and folders. As Windows is commercial, it is not possible to get this level of detail on what its architecture is, but it provides an interesting concept to consider: abstraction.

References
Microsoft. (2019) What is the difference between Cmd, PowerShell, and Bash? | One Dev Question. Available from: https://www.youtube.com/watch?v=nahtw_csB5w [Accessed 22 April 2021].
StackOverflow. (2021) How is it possible for empty files and folders to take zero bytes in Windows. Available from: https://superuser.com/questions/1632439/how-is-it-possible-for-empty-files-and-folders-to-take-zero-bytes-in-windows [Accessed 22 April 2021].
TLDP. (N.D.) 3.1. General overview of the Linux file system. Available from: https://tldp.org/LDP/intro-linux/html/sect_03_01.html [Accessed 22 April 2021].